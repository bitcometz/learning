[1. 背景介绍](#1-背景介绍)
[2. 匹配单个字符](#2-匹配单个字符)
-[2.1 匹配普通文本](#21-匹配普通文本)
-[2.2 匹配任意字符](#22-匹配任意字符)
-[2.3 匹配任意字符](#23-匹配特殊字符)


## 1. 背景介绍
正则表达式是人们为了解决特定的问题而发明的，例如搜索文件、替换特定字符串等。这些用`perl`或者`python`等任何一种语言本身带有等函数都进行处理的，但是解决方案会非常复杂。正则表达式起源于20世纪50年代的数学领域，首先应用于计算机里面的`Perl`和`grep`，后面逐渐得到所有平台及相关语言的支持。
正则表达式主要应用于两个场景：`搜索`和`替换`。

## 2. 匹配单个字符

### 2.1 匹配普通文本
类似下面的例子，我们展示正则表达式的用法，不采取用某个语言来展示。存在文本，正则表达式和结果三部分，其中在结果中以`[]`代表匹配到的结果。[正则在线匹配](https://tool.oschina.net/regex "正则在线")

```diff
+ 文本
Hello, my name is Ben, Please visit 
my website at http://www.forta.com/.

- 正则表达式
Ben

+ 结果
Hello, my name is [Ben], Please visit 
my website at http://www.forta.com/.
```
这里面会一般会涉及两个问题，一个是字母大小写问题，在perl里面一般采取`i`解决，python里面采取`IGNORECASE`标志, 例如下面的：
```perl
$name="aAbBcC";
if($name =~ m/ab/i){
    print "pre match: $` \n";     # 输出a
    print "match: $& \n";         # 输出Ab
    print "post match: $' \n";    # 输出BcC
}
```

```python
import re
m = re.search('multi', 'A mUltiCased string', re.IGNORECASE)
```

另外一个是全局匹配的问题, 例如把`Ben`换成`my`, 这里面有两个匹配结果，一般只返回第一个匹配结果，所以需要根据使用的编程语言来设置，例如perl采取`g`, python使用`re.findall`

### 2.2 匹配任意字符
在正则里面使用`.`可以匹配任意单个字符，例如`c.t` 可以匹配cat和cot

```diff
+ 文本
sales1.xls
orders3.xls
apac1.xls
sales2.xls
sales.xls
na1.xls
na2.xls

- 正则表达式
sales.

+ 结果
[sales1].xls
orders3.xls
apac1.xls
[sales2].xls
[sales.]xls
na1.xls
na2.xls
```
可以看到连本身`.`都被匹配到了：`sales.xls`

### 2.3 匹配特殊字符
接着上面的例子，如何只匹配到`sales.xls`呢？也就是你要告诉正则，现在要匹配到是`.`这个字符，因此必须要在`.`前面加上`\`进行转移，以后遇到匹配特殊字符，例如`\t`, `\n`, '$', '^'，可以从`\`进行思考查找：
```diff
+ 文本
sales1.xls
orders3.xls
apac1.xls
sales2.xls
sales.xls
na1.xls
sa2.xls
ca1.xls

- 正则表达式
sales\.

+ 结果
sales1.xls
orders3.xls
apac1.xls
sales2.xls
[sales.]xls
na1.xls
sa2.xls
ca1.xls
```

## 3. 匹配一组字符
### 3.1 匹配多个字符中的某一个
例如在下面的例子中，只想找到na或者sa开头的xls文件，例如我们还是采取上一章的用法`.a.\.xls`, 这样就会把ca1.xls也找出来了。
解决办法就是采取`[]`来定义字符集合：
```diff
+ 文本
sales1.xls
orders3.xls
apac1.xls
sales2.xls
sales.xls
na1.xls
sa2.xls
ca1.xls
usa2.xls

- 正则表达式
[ns]a.\.xls

+ 结果
sales1.xls
orders3.xls
apac1.xls
sales2.xls
[sales.]xls
[na1.xls]
[sa2.xls]
ca1.xls
[usa2.xls]
```

### 3.2 利用字符区间
上面的例子中，譬如我们增加`sam.xls`，`[ns]a.\.xls`也是可以匹配到的，我们可以采取把`.`换成`[0123456789]`这样的区间代表数字，但这样写麻烦，因此可以改成`[0-9]`
```diff
+ 文本
sales1.xls
orders3.xls
apac1.xls
sales2.xls
sales.xls
na1.xls
sa2.xls
ca1.xls
usa2.xls
sam.xls

- 正则表达式
[ns]a[0-9]\.xls

+ 结果
sales1.xls
orders3.xls
apac1.xls
sales2.xls
[sales.]xls
[na1.xls]
[sa2.xls]
ca1.xls
[usa2.xls]
sam.xls
```
所有大写字母：`[A-Z]`
所有小写字母：`[a-Z]`
所有英文字母：`[A-Za-z]`
字母+数字：`[A-Za-z0-9]`

### 3.3 排除
跟上面相反，我们现在只需要把`sam.xls`匹配出来，就是说要求第三位是非数字。上面的是指定一组必须匹配的字符，但是在某些场合我们需要反过来做。
这个时候就可以采取元字符`^`来操作, 需要在`[]`里面，不然变成匹配开头位置。
```diff
+ 文本
sales1.xls
orders3.xls
apac1.xls
sales2.xls
sales.xls
na1.xls
sa2.xls
ca1.xls
usa2.xls
sam.xls

- 正则表达式
[ns]a[^0-9]\.xls

+ 结果
sales1.xls
orders3.xls
apac1.xls
sales2.xls
sales.xls
na1.xls
sa2.xls
ca1.xls
usa2.xls
[sam.xls]
```
## 4. 使用元字符
前面提到的`.`， '^'， `\`都是元字符，因为元字符在正则里面有特殊的意义，因此无法用来代表它们本身，需要用`\`转义。
更多元字符查看：[正则表达式-元字符](https://www.runoob.com/regexp/regexp-metachar.html "元字符")
大概分成两类：
1. 匹配文本的，例如`.` 
2. 语法组成部分，例如`[]`

下面的例子匹配`myArray[数字]`的模式

```python
+ 文本
if (myArray[0] == 0){
   print('Good')
}

- 正则表达式
myArray\[[0-9]\]  # 可以采取元字符\d代替0-9

+ 结果
if ([myArray[0]] == 0){
   print('Good')
}
```
我们常见的要匹配`\`, 则需要用`\\`
|  元字符      | 说明         |
| ----------  | :-----------: |
| \w         | 任意字母数字+下划线        |
| \W         | 任意非字母数字+非下划线    |
| \d         | 任意数字        |
| \D         | 任意非数字        |
| \s         | 任意一个空白字符        |
| \S         | 任意一个非空白字符        |
| \t         | Tab键        |
| \n         | 换行        |

一些例子
```diff
+ 文本
line1
line2

line3
line4

- 正则表达式
\n\n

+ 结果
line1
line2
[]
line3
line4
```

## 5. 重复匹配
### 5.1 有多少个匹配
利用前面的知识：

```diff
+ 文本
text@text.text

- 正则表达式
\w@\w\.\w

+ 结果
只能匹配a@b.c 这样结果
```

问题在于`\w`只能匹配单个字符，而我们无法预知电子邮件会有多少给字符
|  元字符      | 说明         |
| ----------  | :-----------: |
| +         | 匹配一个或多个字符        |
| *         | 匹配0个或多个字符    |
| ?         | 匹配0个或1个字符        |

### 5.1.1 匹配一个或者多个字符
```diff
+ 文本
Send personal email to ben@forta.com or
ben.forta@forta.com. Fo questions about a
book use support@forta.com. If your message 
is urgent tyr ben@urgent.forta.com. Feel
free to send unsolicited email to 
spam@forta.com (wouldn't it be ncie if it were that simple, huh?)

- 正则表达式
\w+@\w+\.\w+

+ 结果
Send personal email to [ben@forta.com] or
ben.[forta@forta.com]. Fo questions about a
book use [support@forta.com]. If your message 
is urgent tyr [ben@urgent.forta].com. Feel
free to send unsolicited email to 
[spam@forta.com] (wouldn't it be ncie if it were that simple, huh?)
```

注意这里面匹配到了5个邮件地址，但是2个是不够完整到，`ben.[forta@forta.com]` 和 `[ben@urgent.forta].com`, 因为`\w`只能匹配数字字母和下划线，因此我们需要把表达式改成：
`[\w.]+@[\w.]+\.\w+` 注意`+`在外面

### 5.1.2 匹配0个或者多个字符

```
+ 文本
Hello, .ben@forta.com is my email address. # 由于打字错误多了一个 .

- 正则表达式
[\w.]+@[\w.]+\.\w+

+ 结果
Hello, [.ben@forta.com] is my email address.
```
虽然是匹配出来了，但是它不是一个有效但电子邮件地址，因为是以`.`开头，这个时候就是需要匹配零个或者多个字符：`*`, 因此需要把表达式改成：
`\w+[\w.]*@[\w.]+\.\w+` 注意`+`在外面

### 5.1.3 匹配0个或1个字符

```
+ 文本
The URL is http://www.forta.com/, to connect
securely use https:///www.forta.com/ instead.

- 正则表达式
http:\/\/[\w.\/]+

+ 结果
The URL is [http://www.forta.com/], to connect
securely use https:///www.forta.com/ instead.
```
就是现在's'在`http`后面是可选但，如果我们采取`s*` 也不行，是因为`httpssssss://`也能匹配上
所以我们只能利用`?`:
`https?:\/\/[\w.\/]+`

### 5.2 匹配的重复次数
正则里面的`?`, `*`, `+` 解决了许多问题，但是很多时候它们控制不了匹配的范围，这里面就需要用到`{}`
这里面匹配一个日期，天数(1～2位数)、月份(1～2位数)、年份(2～4位数)

```
+ 文本
4/8/17
10-6-2018
2/2/2
01-01-01

- 正则表达式
\d{1,2}[\-\/]\d{1,2}[\-\/]\d{2,4}

+ 结果
[4/8/17]
[10-6-2018]
2/2/2
[01-01-01]
```

### 5.3 匹配至少重复多少次
例如`{3,}`代表至少重复3次，例如下面把大于等于100美元等订单找出来, 其实`+`等同于`{1,}`

```
+ 文本
1001: $485.9
1002: $99.9
1003: $18.6
1004: $1218.6

- 正则表达式
\d+ \$\d{3,}\.\d{2}

+ 结果
[1001: $485.9]
1002: $99.9
1003: $18.6
[1004: $1218.6]
```

### 5.4 防止过度匹配
上面说等除了`?`都是没有匹配上上限等，一般都是采取‘多多益善’等贪婪算法。例如现在要去匹配`<b>`和`<\b>`的模式：

```
+ 文本
This offer is not available to costomers
living in <b>AK</b> and <b>HI</b>.

- 正则表达式
<[Bh]>.*<\/[Bb]>

+ 结果
This offer is not available to costomers
living in [<b>AK</b> and <b>HI</b>].
```
|  贪婪型量词      | 懒惰型量词         |
| ----------  | :-----------: |
| *         |      \*?   |
| +         | +?    |
| {n,}         | {n,}?        |












