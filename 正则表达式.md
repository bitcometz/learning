## 1. 背景介绍
正则表达式是人们为了解决特定的问题而发明的，例如搜索文件、替换特定字符串等。这些用perl或者python等任何一种语言本身带有等函数都进行处理的，但是解决方案会非常复杂。正则表达式起源于20世纪50年代的数学领域，首先应用于计算机里面的Perl和grep，后面逐渐得到所有平台及相关语言的支持。
正则表达式主要应用于两个场景：`搜索`和`替换`。

## 2. 匹配单个字符

### 2.1 匹配普通文本
类似下面的例子，我们展示正则表达式的用法，不采取用某个语言来展示。存在文本，正则表达式和结果三部分，其中在结果中以[]代表匹配到的结果。[正则在线匹配](https://tool.oschina.net/regex "正则在线")

```diff
+ 文本
Hello, my name is Ben, Please visit 
my website at http://www.forta.com/.

- 正则表达式
Ben

+ 结果
Hello, my name is [Ben], Please visit 
my website at http://www.forta.com/.
```
这里面会一般会涉及两个问题，一个是字母大小写问题，在perl里面一般采取`i`解决，python里面采取`IGNORECASE`标志, 例如下面的：
```perl
$name="aAbBcC";
if($name =~ m/ab/i){
    print "pre match: $` \n";     # 输出a
    print "match: $& \n";         # 输出Ab
    print "post match: $' \n";    # 输出BcC
}
```

```python
import re
m = re.search('multi', 'A mUltiCased string', re.IGNORECASE)
```

另外一个是全局匹配的问题, 例如把`Ben`换成`my`, 这里面有两个匹配结果，一般只返回第一个匹配结果，所以需要根据使用的编程语言来设置，例如perl采取`g`, python使用`re.findall`

### 2.1 匹配任意字符
在正则里面使用`.`可以匹配任意单个字符，例如`c.t` 可以匹配cat和cot

```diff
+ 文本
sales1.xls
orders3.xls
apac1.xls
sales2.xls
sales.xls
na1.xls
na2.xls

- 正则表达式
sales.

+ 结果
[sales1].xls
orders3.xls
apac1.xls
[sales2].xls
[sales.]xls
na1.xls
na2.xls
```
可以看到连本身`.`都被匹配到了：`sales.xls`

### 2.1 匹配特殊字符
接着上面的例子，如何只匹配到`sales.xls`呢？也就是你要告诉正则，现在要匹配到是`.`这个字符，因此必须要在`.`前面加上`\`进行转移，以后遇到匹配特殊字符，例如`\t`, `\n`, '$', '^'，可以从`\`进行思考查找：
```diff
+ 文本
sales1.xls
orders3.xls
apac1.xls
sales2.xls
sales.xls
na1.xls
sa2.xls
ca1.xls

- 正则表达式
sales\.

+ 结果
sales1.xls
orders3.xls
apac1.xls
sales2.xls
[sales.]xls
na1.xls
sa2.xls
ca1.xls
```

## 3. 匹配一组字符
### 3.1 匹配多个字符中的某一个
例如在下面的例子中，只想找到na或者sa开头的xls文件，例如我们还是采取上一章的用法`.a.\.xls`, 这样就会把ca1.xls也找出来了。
解决办法就是采取`[]`来定义字符集合：
```diff
+ 文本
sales1.xls
orders3.xls
apac1.xls
sales2.xls
sales.xls
na1.xls
sa2.xls
ca1.xls
usa2.xls

- 正则表达式
[ns]a.\.xls

+ 结果
sales1.xls
orders3.xls
apac1.xls
sales2.xls
[sales.]xls
[na1.xls]
[sa2.xls]
ca1.xls
[usa2.xls]
```

### 3.2 利用字符区间
上面的例子中，譬如我们增加`sam.xls`，`[ns]a.\.xls`也是可以匹配到的，我们可以采取把`.`换成`[0123456789]`这样的区间代表数字，但这样写麻烦，因此可以改成`[0-9]`
```diff
+ 文本
sales1.xls
orders3.xls
apac1.xls
sales2.xls
sales.xls
na1.xls
sa2.xls
ca1.xls
usa2.xls
sam.xls

- 正则表达式
[ns]a[0-9]\.xls

+ 结果
sales1.xls
orders3.xls
apac1.xls
sales2.xls
[sales.]xls
[na1.xls]
[sa2.xls]
ca1.xls
[usa2.xls]
sam.xls
```
所有大写字母：`[A-Z]`
所有小写字母：`[a-Z]`
所有英文字母：`[A-Za-z]`
字母+数字：`[A-Za-z0-9]`

### 3.3 排除
跟上面相反，我们现在只需要把`sam.xls`匹配出来，就是说要求第三位是非数字。上面的是指定一组必须匹配的字符，但是在某些场合我们需要反过来做。
这个时候就可以采取元字符`^`来操作, 需要在`[]`里面，不然变成匹配开头位置。
```diff
+ 文本
sales1.xls
orders3.xls
apac1.xls
sales2.xls
sales.xls
na1.xls
sa2.xls
ca1.xls
usa2.xls
sam.xls

- 正则表达式
[ns]a[^0-9]\.xls

+ 结果
sales1.xls
orders3.xls
apac1.xls
sales2.xls
sales.xls
na1.xls
sa2.xls
ca1.xls
usa2.xls
[sam.xls]
```
## 4. 使用元字符
前面提到的`.`， '^'， `\`都是元字符，因为元字符在正则里面有特殊的意义，因此无法用来代表它们本身，需要用`\`转义。
更多元字符查看：[正则表达式-元字符](https://www.runoob.com/regexp/regexp-metachar.html "元字符")
下面的例子匹配`myArray[数字]`的模式

```python
+ 文本
if (myArray[0] == 0){
   print('Good')
}

- 正则表达式
myArray\[[0-9]\]  # 可以采取元字符\d代替0-9

+ 结果
if ([myArray[0]] == 0){
   print('Good')
}
```
我们常见的要匹配`\`, 则需要用`\\`
|  元字符      | 说明         |
| ----------  | :-----------: |
| \w         | 任意字母数字+下划线    |




